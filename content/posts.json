{
  "posts": {
    "nodes": [
      {
        "title": "Click pixel-perfect on HTML5 Canvas sprites",
        "slug": "click-pixel-perfect-on-html5-canvas-sprites",
        "content": "<h2>Summary</h2>\n<p>There is no way to draw a sprite and capture a pixel-perfect click on an HTML5 canvas. But there's a trick!</p>\n<p>The goal is to assign a random color to each of our sprites in their properties. We then create a new canvas that will serve as a buffer where we draw each sprite but only in their unique color.<br />\nNext, we capture the click event on the main canvas, we then examine the color of the pixel with its coordinates on the buffer and then compare this color with the one recorded in the Sprites and we can then find the corresponding Sprite.</p>\n<p>Tada! A pixel-perfect mouse click!</p>\n<p><a href=\"https://leoche.github.io/Pixelperfect-Click-Canvas\">Link to the Demo</a></p>\n<h2>Initial Setup</h2>\n<p>I use three sprites taken from the internet</p>\n<p><img decoding=\"async\" src=\"https://raw.githubusercontent.com/Leoche/Pixelperfect-Click-Canvas/master/docs/assets/ill0.png\" alt=\"ill0\" /></p>\n<p>To start, we have a <code>Main</code> class that has an <code>Array</code> of Sprite(x, y, img) instances:</p>\n<pre><code class=\"language-javascript\">this.sprites = [\n  new Sprite(100, 100, this.imgs.bed),\n  new Sprite(52, 146, this.imgs.table),\n  new Sprite(80, 135, this.imgs.z)\n]</code></pre>\n<p><em>I deliberately set these coordinates by hand so that the sprites intermingle</em></p>\n<p>The Sprite class is rather basic:</p>\n<pre><code class=\"language-javascript\">export default class Sprite {\n  constructor(x, y, img) {\n    this.x = x\n    this.y = y\n    this.img = img\n  }\n  render (ctx) {\n    ctx.drawImage(this.img, this.x, this.y)\n  }\n}</code></pre>\n<p>For this example, I did not put a <code>z</code> or <code>depth</code> property, we assume here that the sprites are ordered according to their position in the sprite array.<br />\nI then start a rendering loop that calls the <code>render</code> functions of each sprite:</p>\n<pre><code class=\"language-javascript\">setInterval(() =&gt; this.render(), 1000 / 30)\n\n...\n\nrender () {\n  ...\n\n  this.sprites.forEach( sprite =&gt; {\n      sprite.render(this.ctx)\n  })\n}</code></pre>\n<p>Result:</p>\n<p><img decoding=\"async\" src=\"https://raw.githubusercontent.com/Leoche/Pixelperfect-Click-Canvas/master/docs/assets/ill1.png\" alt=\"ill1\" /></p>\n<h2>The real things begin</h2>\n<p>First, we need to generate a random color for each Sprite and create a new rendering method that will draw the sprite by filling it only with its color.</p>\n<pre><code class=\"language-javascript\">constructor(x, y, img) {\n  this.x = x\n  this.y = y\n  this.img = img\n  this.name = this.img.id.replace('img-', '')\n   // Returns 'bed', 'table' or 'z'\n  this.id = Math.floor(Math.random()*16777215).toString(16);\n   // Returns a random HEX color\n  console.log(\"Created '\" + this.name + \"' with color #\" + this.id);\n   //We then log the generated color for each sprite\n}</code></pre>\n<p>The console then returns:</p>\n<p><img decoding=\"async\" src=\"https://raw.githubusercontent.com/Leoche/Pixelperfect-Click-Canvas/master/docs/assets/ill3.png\" alt=\"ill3\" /></p>\n<p>Now we want to create a <code>renderColor</code> method in the sprites that will create a virtual rendering with a buffer. To do this, we create our buffer canvas with the dimensions of the sprite, fill it entirely with its color, then draw the sprite with a <code>destination-atop</code> composition.</p>\n<pre><code class=\"language-javascript\">renderColor (ctx) {\n  var buffer = document.createElement('canvas');\n      buffer.width = this.img.width;\n      buffer.height = this.img.height;\n  var bx = buffer.getContext('2d');\n  bx.fillStyle = '#' + this.id\n  bx.fillRect(0,0,buffer.width,buffer.height);\n  bx.globalCompositeOperation = \"destination-atop\";\n  bx.drawImage(this.img,0,0);\n  ctx.drawImage(buffer, this.x, this.y)\n}</code></pre>\n<p>For debugging reasons, we can update the main <code>render</code> by drawing these colored sprites after the real rendering of our sprites:</p>\n<p>We can thus see the result of our buffer:</p>\n<p><img decoding=\"async\" src=\"https://raw.githubusercontent.com/Leoche/Pixelperfect-Click-Canvas/master/docs/assets/ill2.png\" alt=\"ill2\" /></p>\n<p>Now our goal is to put this overall rendering into a single buffer, so we need to create it and move the rendering into this buffer.</p>\n<pre><code class=\"language-javascript\">this.inputCanvas = document.createElement('canvas')\nthis.inputCanvas.width = this.canvas.width\nthis.inputCanvas.height = this.canvas.width\nthis.inputCanvasCtx = this.inputCanvas.getContext('2d')\n\n...\n\nrender () {\n  this.sprites.forEach( sprite =&gt; {\n      sprite.render(this.ctx)\n      // Previously:  sprite.renderColor(this.ctx)\n      sprite.renderColor(this.inputCanvasCtx)\n  })\n}</code></pre>\n<p>Then we add a click event listener on the main canvas and capture the pixel information from the buffer with the coordinates given by the event.</p>\n<pre><code class=\"language-javascript\">this.canvas.addEventListener('click', event =&gt; {\n  let color = this.inputCanvasCtx.getImageData(event.layerX, event.layerY, 1, 1).data\n})</code></pre>\n<p>We just need to convert the RGB color to HEX and compare the colors!</p>\n<pre><code class=\"language-javascript\">this.canvas.addEventListener('click', event =&gt; {\n  let color = this.inputCanvasCtx.getImageData(event.layerX, event.layerY, 1, 1).data\n  let hexColor = (\"000000\" + this.rgbToHex(color[0], color[1], color[2])).slice(-6)\n\n  console.log('You just clicked on color #' + hexColor)\n\n  let sprite = this.sprites.filter(sprite =&gt; sprite.id === hexColor)\n  // We then have the clicked sprite\n})\n\n...\n\n// RGB Util\nrgbToHex(r, g, b) {\n  if (r &gt; 255 || g &gt; 255 || b &gt; 255)\n      throw \"Invalid color component\"\n  return ((r &lt;&lt; 16) | (g &lt;&lt; 8) | b).toString(16)\n}</code></pre>\n<p>Console Return:</p>\n<p><img decoding=\"async\" src=\"https://raw.githubusercontent.com/Leoche/Pixelperfect-Click-Canvas/master/docs/assets/ill4.png\" alt=\"ill4\" /></p>\n<p>We then have the clicked sprite in a totally pixel perfect way</p>\n<p>Hoping this helps someone one day üôÇ !</p>\n<p><a href=\"https://github.com/Leoche/Pixelperfect-Click-Canvas\">Link to the Repo</a></p>\n<p><a href=\"https://leoche.github.io/Pixelperfect-Click-Canvas\">Link to the Demo</a></p>\n",
        "excerpt": "<p>There is no way to draw a sprite and capture a click in a pixel perfect manner on an HTML5 canvas. But there is a trick&#8230;</p>\n",
        "featuredImage": {
          "node": {
            "sourceUrl": "https://wp.leodesigaux.com/wp-content/uploads/2024/08/preview.png"
          }
        },
        "categories": {
          "edges": [
            {
              "node": {
                "name": "Non class√©",
                "slug": "non-classe"
              }
            }
          ]
        },
        "author": {
          "node": {
            "name": "Leoche",
            "avatar": {
              "url": "https://secure.gravatar.com/avatar/725d10949bebbbcebf092ade3d520748?s=96&d=mm&r=g"
            }
          }
        },
        "date": "2024-08-26T17:55:09",
        "modified": "2024-08-28T21:54:25",
        "translations": [
          {
            "title": "Clique pixel-perfect sur sprites HTML5 Canvas",
            "slug": "mouse-click-pixel-perfect-on-sprites-for-html5-canvas",
            "content": "<h2>Sommaire</h2>\n<p>Il n'y a aucun moyen de dessiner un sprite et de capturer un clique de mani√®re pixel perfect sur un canvas HTML5. Mais il y'a une astuce!</p>\n<p>Le but est d'attribuer une couleur random √† chacun de nos sprites dans ses propriet√©s. On cr√©e alors un nouveau canvas qui nous servira de buffer o√π l'on dessine chaque sprite mais seulement de leur unique couleur.<br />\nEnsuite on capture l'event du clic sur le canvas principal, on examine alors la couleur du pixel avec ses coordon√©es sur le buffer et on compare ensuite cette couleur avec celle enregistr√©e dans les Sprites et on peut trouver alors le Sprite correspondant.</p>\n<p>Tada! Un mouse click pixel perfect!</p>\n<p><a href=\"https://leoche.github.io/Pixelperfect-Click-Canvas\">Liens vers la D√©mo</a></p>\n<h2>Setup initial</h2>\n<p>J'utilise trois sprites prise sur internet</p>\n<p><img decoding=\"async\" src=\"https://raw.githubusercontent.com/Leoche/Pixelperfect-Click-Canvas/master/docs/assets/ill0.png\" alt=\"ill0\" /></p>\n<p>Pour commencer, on a une classe <code>Main</code> qui poss√®de un <code>Array</code> d'instances de Sprite(x, y ,img):</p>\n<pre><code class=\"language-javascript\">this.sprites = [\n  new Sprite(100, 100, this.imgs.bed),\n  new Sprite(52, 146, this.imgs.table),\n  new Sprite(80, 135, this.imgs.z)\n]</code></pre>\n<p><em>J'ai volontairement mis ces coordon√©es √† la main pour que les sprites s'entrem√™lent</em></p>\n<p>La classe Sprite est plut√¥t basique:</p>\n<pre><code class=\"language-javascript\">export default class Sprite {\n  constructor(x, y, img) {\n    this.x = x\n    this.y = y\n    this.img = img\n  }\n  render (ctx) {\n    ctx.drawImage(this.img, this.x, this.y)\n  }\n}</code></pre>\n<p>Pour cet exemple, je n'ai pas mis de propri√©t√© <code>z</code> ou <code>depth</code>, on admet ici que les sprites sont ordonn√©es selon leur position dans le tableau de sprites.<br />\nJe met alors en route une boucle de rendu qui appelle les fonctions <code>render</code> de chaque sprite:</p>\n<pre><code class=\"language-javascript\">setInterval(() =&gt; this.render(), 1000 / 30)\n\n...\n\nrender () {\n  ...\n\n  this.sprites.forEach( sprite =&gt; {\n      sprite.render(this.ctx)\n  })\n}</code></pre>\n<p>R√©sultat:</p>\n<p><img decoding=\"async\" src=\"https://raw.githubusercontent.com/Leoche/Pixelperfect-Click-Canvas/master/docs/assets/ill1.png\" alt=\"ill1\" /></p>\n<h2>Les vrais choses commencent</h2>\n<p>Premi√®rement on doit g√©n√©rer une couleur al√©atoire √† chaque Sprite et cr√©er une nouvelle m√©thode de rendu qui dessinera la sprite en la remplissant uniquement de sa couleur.</p>\n<pre><code class=\"language-javascript\">constructor(x, y, img) {\n  this.x = x\n  this.y = y\n  this.img = img\n  this.name = this.img.id.replace(&#039;img-&#039;, &#039;&#039;)\n   // Retourne &#039;bed&#039;, &#039;table&#039; or &#039;z&#039;\n  this.id = Math.floor(Math.random()*16777215).toString(16);\n   // Retourne une couleur HEX random\n  console.log(&quot;Created &#039;&quot; + this.name + &quot;&#039; with color #&quot; + this.id);\n   //On log alors la couleur g√©n√©r√©e pour chaque sprite\n}</code></pre>\n<p>La console nous retourne alors:</p>\n<p><img decoding=\"async\" src=\"https://raw.githubusercontent.com/Leoche/Pixelperfect-Click-Canvas/master/docs/assets/ill3.png\" alt=\"ill3\" /></p>\n<p>Maintenant nous voulons cr√©er une m√©thode <code>renderColor</code> dans les sprites qui cr√©era un rendu virtuel avec un buffer. Pour ce faire on cr√©e notre canvas buffer avec les dimensions du sprite, on le rempli enti√®rement de sa couleur puis dessine la sprite avec une composition <code>destination-atop</code>.</p>\n<pre><code class=\"language-javascript\">renderColor (ctx) {\n  var buffer = document.createElement(&#039;canvas&#039;);\n      buffer.width = this.img.width;\n      buffer.height = this.img.height;\n  var bx = buffer.getContext(&#039;2d&#039;);\n  bx.fillStyle = &#039;#&#039; + this.id\n  bx.fillRect(0,0,buffer.width,buffer.height);\n  bx.globalCompositeOperation = &quot;destination-atop&quot;;\n  bx.drawImage(this.img,0,0);\n  ctx.drawImage(buffer, this.x, this.y)\n}</code></pre>\n<p>Pour des raisons de debug, On peut update le <code>render</code> principal en dessinant ces sprites color√©es apr√®s le v√©ritable rendu de nos sprites:</p>\n<pre><code class=\"language-javascript\">render () {\n  this.sprites.forEach( sprite =&gt; {\n      sprite.render(this.ctx)\n      sprite.renderColor(this.ctx) //DEBUG\n  })\n}</code></pre>\n<p>On peut ainsi voir le r√©sultat de notre buffer:</p>\n<p><img decoding=\"async\" src=\"https://raw.githubusercontent.com/Leoche/Pixelperfect-Click-Canvas/master/docs/assets/ill2.png\" alt=\"ill2\" /></p>\n<p>Maintenant notre but est de mettre ce rendu global dans un seul et unique buffer, il nous faut donc le cr√©e et d√©placer le rendu dans ce buffer.</p>\n<pre><code class=\"language-javascript\">this.inputCanvas = document.createElement(&#039;canvas&#039;)\nthis.inputCanvas.width = this.canvas.width\nthis.inputCanvas.height = this.canvas.width\nthis.inputCanvasCtx = this.inputCanvas.getContext(&#039;2d&#039;)\n\n...\n\nrender () {\n  this.sprites.forEach( sprite =&gt; {\n      sprite.render(this.ctx)\n      // Pr√©c√©dement:  sprite.renderColor(this.ctx)\n      sprite.renderColor(this.inputCanvasCtx)\n  })\n}</code></pre>\n<p>Ensuite on ajoute un √©couteur d'√©v√©nement de clics sur le canvas principal et on capture les informations du pixel sur le buffer avec les coordonn√©es donn√© par l'√©venement.</p>\n<pre><code class=\"language-javascript\">this.canvas.addEventListener(&#039;click&#039;, event =&gt; {\n  let color = this.inputCanvasCtx.getImageData(event.layerX, event.layerY, 1, 1).data\n})</code></pre>\n<p>Il nous suffit alors de convertir la couleur RGB en HEX et comparer les couleurs!</p>\n<pre><code class=\"language-javascript\">this.canvas.addEventListener(&#039;click&#039;, event =&gt; {\n  let color = this.inputCanvasCtx.getImageData(event.layerX, event.layerY, 1, 1).data\n  let hexColor = (&quot;000000&quot; + this.rgbToHex(color[0], color[1], color[2])).slice(-6)\n\n  console.log(&#039;You just clicked on color #&#039; + hexColor)\n\n  let sprite = this.sprites.filter(sprite =&gt; sprite.id === hexColor)\n  // On a alors la sprite cliqu√©e\n})\n\n...\n\n// RGB Util\nrgbToHex(r, g, b) {\n  if (r &gt; 255 || g &gt; 255 || b &gt; 255)\n      throw &quot;Invalid color component&quot;\n  return ((r &lt;&lt; 16) | (g &lt;&lt; 8) | b).toString(16)\n}</code></pre>\n<p>Retour Console:</p>\n<p><img decoding=\"async\" src=\"https://raw.githubusercontent.com/Leoche/Pixelperfect-Click-Canvas/master/docs/assets/ill4.png\" alt=\"ill4\" /></p>\n<p>On a alors la sprite cliqu√©e de mani√®re totalement pixel perfect</p>\n<p>En esp√©rant que √ßa aide quelqu'un un jour üôÇ !</p>\n<p><a href=\"https://github.com/Leoche/Pixelperfect-Click-Canvas\">Liens vers le Repo</a></p>\n<p><a href=\"https://leoche.github.io/Pixelperfect-Click-Canvas\">Liens vers la D√©mo</a></p>\n",
            "excerpt": "<p>Il n&#8217;y a aucun moyen de dessiner un sprite et de capturer un clique de mani√®re pixel perfect sur un canvas HTML5. Mais il y&#8217;a une astuce&#8230;</p>\n"
          }
        ]
      }
    ]
  }
}