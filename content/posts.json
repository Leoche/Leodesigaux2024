{
  "posts": {
    "nodes": [
      {
        "title": "Click pixel-perfect on HTML5 Canvas sprites",
        "slug": "click-pixel-perfect-on-html5-canvas-sprites",
        "content": "<h2>Summary</h2>\n<p>There is no way to draw a sprite and capture a pixel-perfect click on an HTML5 canvas. But there's a trick!</p>\n<p>The goal is to assign a random color to each of our sprites in their properties. We then create a new canvas that will serve as a buffer where we draw each sprite but only in their unique color.<br />\nNext, we capture the click event on the main canvas, we then examine the color of the pixel with its coordinates on the buffer and then compare this color with the one recorded in the Sprites and we can then find the corresponding Sprite.</p>\n<p>Tada! A pixel-perfect mouse click!</p>\n<p><a href=\"https://leoche.github.io/Pixelperfect-Click-Canvas\">Link to the Demo</a></p>\n<h2>Initial Setup</h2>\n<p>I use three sprites taken from the internet</p>\n<p><img decoding=\"async\" src=\"https://raw.githubusercontent.com/Leoche/Pixelperfect-Click-Canvas/master/docs/assets/ill0.png\" alt=\"ill0\" /></p>\n<p>To start, we have a <code>Main</code> class that has an <code>Array</code> of Sprite(x, y, img) instances:</p>\n<pre><code class=\"language-javascript\">this.sprites = [\n  new Sprite(100, 100, this.imgs.bed),\n  new Sprite(52, 146, this.imgs.table),\n  new Sprite(80, 135, this.imgs.z)\n]</code></pre>\n<p><em>I deliberately set these coordinates by hand so that the sprites intermingle</em></p>\n<p>The Sprite class is rather basic:</p>\n<pre><code class=\"language-javascript\">export default class Sprite {\n  constructor(x, y, img) {\n    this.x = x\n    this.y = y\n    this.img = img\n  }\n  render (ctx) {\n    ctx.drawImage(this.img, this.x, this.y)\n  }\n}</code></pre>\n<p>For this example, I did not put a <code>z</code> or <code>depth</code> property, we assume here that the sprites are ordered according to their position in the sprite array.<br />\nI then start a rendering loop that calls the <code>render</code> functions of each sprite:</p>\n<pre><code class=\"language-javascript\">setInterval(() =&gt; this.render(), 1000 / 30)\n\n...\n\nrender () {\n  ...\n\n  this.sprites.forEach( sprite =&gt; {\n      sprite.render(this.ctx)\n  })\n}</code></pre>\n<p>Result:</p>\n<p><img decoding=\"async\" src=\"https://raw.githubusercontent.com/Leoche/Pixelperfect-Click-Canvas/master/docs/assets/ill1.png\" alt=\"ill1\" /></p>\n<h2>The real things begin</h2>\n<p>First, we need to generate a random color for each Sprite and create a new rendering method that will draw the sprite by filling it only with its color.</p>\n<pre><code class=\"language-javascript\">constructor(x, y, img) {\n  this.x = x\n  this.y = y\n  this.img = img\n  this.name = this.img.id.replace('img-', '')\n   // Returns 'bed', 'table' or 'z'\n  this.id = Math.floor(Math.random()*16777215).toString(16);\n   // Returns a random HEX color\n  console.log(\"Created '\" + this.name + \"' with color #\" + this.id);\n   //We then log the generated color for each sprite\n}</code></pre>\n<p>The console then returns:</p>\n<p><img decoding=\"async\" src=\"https://raw.githubusercontent.com/Leoche/Pixelperfect-Click-Canvas/master/docs/assets/ill3.png\" alt=\"ill3\" /></p>\n<p>Now we want to create a <code>renderColor</code> method in the sprites that will create a virtual rendering with a buffer. To do this, we create our buffer canvas with the dimensions of the sprite, fill it entirely with its color, then draw the sprite with a <code>destination-atop</code> composition.</p>\n<pre><code class=\"language-javascript\">renderColor (ctx) {\n  var buffer = document.createElement('canvas');\n      buffer.width = this.img.width;\n      buffer.height = this.img.height;\n  var bx = buffer.getContext('2d');\n  bx.fillStyle = '#' + this.id\n  bx.fillRect(0,0,buffer.width,buffer.height);\n  bx.globalCompositeOperation = \"destination-atop\";\n  bx.drawImage(this.img,0,0);\n  ctx.drawImage(buffer, this.x, this.y)\n}</code></pre>\n<p>For debugging reasons, we can update the main <code>render</code> by drawing these colored sprites after the real rendering of our sprites:</p>\n<p>We can thus see the result of our buffer:</p>\n<p><img decoding=\"async\" src=\"https://raw.githubusercontent.com/Leoche/Pixelperfect-Click-Canvas/master/docs/assets/ill2.png\" alt=\"ill2\" /></p>\n<p>Now our goal is to put this overall rendering into a single buffer, so we need to create it and move the rendering into this buffer.</p>\n<pre><code class=\"language-javascript\">this.inputCanvas = document.createElement('canvas')\nthis.inputCanvas.width = this.canvas.width\nthis.inputCanvas.height = this.canvas.width\nthis.inputCanvasCtx = this.inputCanvas.getContext('2d')\n\n...\n\nrender () {\n  this.sprites.forEach( sprite =&gt; {\n      sprite.render(this.ctx)\n      // Previously:  sprite.renderColor(this.ctx)\n      sprite.renderColor(this.inputCanvasCtx)\n  })\n}</code></pre>\n<p>Then we add a click event listener on the main canvas and capture the pixel information from the buffer with the coordinates given by the event.</p>\n<pre><code class=\"language-javascript\">this.canvas.addEventListener('click', event =&gt; {\n  let color = this.inputCanvasCtx.getImageData(event.layerX, event.layerY, 1, 1).data\n})</code></pre>\n<p>We just need to convert the RGB color to HEX and compare the colors!</p>\n<pre><code class=\"language-javascript\">this.canvas.addEventListener('click', event =&gt; {\n  let color = this.inputCanvasCtx.getImageData(event.layerX, event.layerY, 1, 1).data\n  let hexColor = (\"000000\" + this.rgbToHex(color[0], color[1], color[2])).slice(-6)\n\n  console.log('You just clicked on color #' + hexColor)\n\n  let sprite = this.sprites.filter(sprite =&gt; sprite.id === hexColor)\n  // We then have the clicked sprite\n})\n\n...\n\n// RGB Util\nrgbToHex(r, g, b) {\n  if (r &gt; 255 || g &gt; 255 || b &gt; 255)\n      throw \"Invalid color component\"\n  return ((r &lt;&lt; 16) | (g &lt;&lt; 8) | b).toString(16)\n}</code></pre>\n<p>Console Return:</p>\n<p><img decoding=\"async\" src=\"https://raw.githubusercontent.com/Leoche/Pixelperfect-Click-Canvas/master/docs/assets/ill4.png\" alt=\"ill4\" /></p>\n<p>We then have the clicked sprite in a totally pixel perfect way</p>\n<p>Hoping this helps someone one day üôÇ !</p>\n<p><a href=\"https://github.com/Leoche/Pixelperfect-Click-Canvas\">Link to the Repo</a></p>\n<p><a href=\"https://leoche.github.io/Pixelperfect-Click-Canvas\">Link to the Demo</a></p>\n",
        "excerpt": "<p>There is no way to draw a sprite and capture a click in a pixel perfect manner on an HTML5 canvas. But there is a trick&#8230;</p>\n",
        "featuredImage": {
          "node": {
            "sourceUrl": "https://wp.leodesigaux.com/wp-content/uploads/2024/08/preview.png"
          }
        },
        "categories": {
          "edges": [
            {
              "node": {
                "name": "Canvas HTML5",
                "slug": "canvas-html5-en"
              }
            },
            {
              "node": {
                "name": "Non class√©",
                "slug": "non-classe"
              }
            }
          ]
        },
        "author": {
          "node": {
            "name": "Leoche",
            "avatar": {
              "url": "https://secure.gravatar.com/avatar/725d10949bebbbcebf092ade3d520748?s=96&d=mm&r=g"
            }
          }
        },
        "date": "2024-08-26T17:55:09",
        "modified": "2024-09-30T21:16:14",
        "translations": [
          {
            "title": "Clique pixel-perfect sur sprites HTML5 Canvas",
            "slug": "mouse-click-pixel-perfect-on-sprites-for-html5-canvas",
            "content": "<h2>Sommaire</h2>\n<p>Il n'y a aucun moyen de dessiner un sprite et de capturer un clique de mani√®re pixel perfect sur un canvas HTML5. Mais il y'a une astuce!</p>\n<p>Le but est d'attribuer une couleur random √† chacun de nos sprites dans ses propriet√©s. On cr√©e alors un nouveau canvas qui nous servira de buffer o√π l'on dessine chaque sprite mais seulement de leur unique couleur.<br />\nEnsuite on capture l'event du clic sur le canvas principal, on examine alors la couleur du pixel avec ses coordon√©es sur le buffer et on compare ensuite cette couleur avec celle enregistr√©e dans les Sprites et on peut trouver alors le Sprite correspondant.</p>\n<p>Tada! Un mouse click pixel perfect!</p>\n<p><a href=\"https://leoche.github.io/Pixelperfect-Click-Canvas\">Liens vers la D√©mo</a></p>\n<h2>Setup initial</h2>\n<p>J'utilise trois sprites prise sur internet</p>\n<p><img decoding=\"async\" src=\"https://raw.githubusercontent.com/Leoche/Pixelperfect-Click-Canvas/master/docs/assets/ill0.png\" alt=\"ill0\" /></p>\n<p>Pour commencer, on a une classe <code>Main</code> qui poss√®de un <code>Array</code> d'instances de Sprite(x, y ,img):</p>\n<pre><code class=\"language-javascript\">this.sprites = [\n  new Sprite(100, 100, this.imgs.bed),\n  new Sprite(52, 146, this.imgs.table),\n  new Sprite(80, 135, this.imgs.z)\n]</code></pre>\n<p><em>J'ai volontairement mis ces coordon√©es √† la main pour que les sprites s'entrem√™lent</em></p>\n<p>La classe Sprite est plut√¥t basique:</p>\n<pre><code class=\"language-javascript\">export default class Sprite {\n  constructor(x, y, img) {\n    this.x = x\n    this.y = y\n    this.img = img\n  }\n  render (ctx) {\n    ctx.drawImage(this.img, this.x, this.y)\n  }\n}</code></pre>\n<p>Pour cet exemple, je n'ai pas mis de propri√©t√© <code>z</code> ou <code>depth</code>, on admet ici que les sprites sont ordonn√©es selon leur position dans le tableau de sprites.<br />\nJe met alors en route une boucle de rendu qui appelle les fonctions <code>render</code> de chaque sprite:</p>\n<pre><code class=\"language-javascript\">setInterval(() =&gt; this.render(), 1000 / 30)\n\n...\n\nrender () {\n  ...\n\n  this.sprites.forEach( sprite =&gt; {\n      sprite.render(this.ctx)\n  })\n}</code></pre>\n<p>R√©sultat:</p>\n<p><img decoding=\"async\" src=\"https://raw.githubusercontent.com/Leoche/Pixelperfect-Click-Canvas/master/docs/assets/ill1.png\" alt=\"ill1\" /></p>\n<h2>Les vrais choses commencent</h2>\n<p>Premi√®rement on doit g√©n√©rer une couleur al√©atoire √† chaque Sprite et cr√©er une nouvelle m√©thode de rendu qui dessinera la sprite en la remplissant uniquement de sa couleur.</p>\n<pre><code class=\"language-javascript\">constructor(x, y, img) {\n  this.x = x\n  this.y = y\n  this.img = img\n  this.name = this.img.id.replace(&#039;img-&#039;, &#039;&#039;)\n   // Retourne &#039;bed&#039;, &#039;table&#039; or &#039;z&#039;\n  this.id = Math.floor(Math.random()*16777215).toString(16);\n   // Retourne une couleur HEX random\n  console.log(&quot;Created &#039;&quot; + this.name + &quot;&#039; with color #&quot; + this.id);\n   //On log alors la couleur g√©n√©r√©e pour chaque sprite\n}</code></pre>\n<p>La console nous retourne alors:</p>\n<p><img decoding=\"async\" src=\"https://raw.githubusercontent.com/Leoche/Pixelperfect-Click-Canvas/master/docs/assets/ill3.png\" alt=\"ill3\" /></p>\n<p>Maintenant nous voulons cr√©er une m√©thode <code>renderColor</code> dans les sprites qui cr√©era un rendu virtuel avec un buffer. Pour ce faire on cr√©e notre canvas buffer avec les dimensions du sprite, on le rempli enti√®rement de sa couleur puis dessine la sprite avec une composition <code>destination-atop</code>.</p>\n<pre><code class=\"language-javascript\">renderColor (ctx) {\n  var buffer = document.createElement(&#039;canvas&#039;);\n      buffer.width = this.img.width;\n      buffer.height = this.img.height;\n  var bx = buffer.getContext(&#039;2d&#039;);\n  bx.fillStyle = &#039;#&#039; + this.id\n  bx.fillRect(0,0,buffer.width,buffer.height);\n  bx.globalCompositeOperation = &quot;destination-atop&quot;;\n  bx.drawImage(this.img,0,0);\n  ctx.drawImage(buffer, this.x, this.y)\n}</code></pre>\n<p>Pour des raisons de debug, On peut update le <code>render</code> principal en dessinant ces sprites color√©es apr√®s le v√©ritable rendu de nos sprites:</p>\n<pre><code class=\"language-javascript\">render () {\n  this.sprites.forEach( sprite =&gt; {\n      sprite.render(this.ctx)\n      sprite.renderColor(this.ctx) //DEBUG\n  })\n}</code></pre>\n<p>On peut ainsi voir le r√©sultat de notre buffer:</p>\n<p><img decoding=\"async\" src=\"https://raw.githubusercontent.com/Leoche/Pixelperfect-Click-Canvas/master/docs/assets/ill2.png\" alt=\"ill2\" /></p>\n<p>Maintenant notre but est de mettre ce rendu global dans un seul et unique buffer, il nous faut donc le cr√©e et d√©placer le rendu dans ce buffer.</p>\n<pre><code class=\"language-javascript\">this.inputCanvas = document.createElement(&#039;canvas&#039;)\nthis.inputCanvas.width = this.canvas.width\nthis.inputCanvas.height = this.canvas.width\nthis.inputCanvasCtx = this.inputCanvas.getContext(&#039;2d&#039;)\n\n...\n\nrender () {\n  this.sprites.forEach( sprite =&gt; {\n      sprite.render(this.ctx)\n      // Pr√©c√©dement:  sprite.renderColor(this.ctx)\n      sprite.renderColor(this.inputCanvasCtx)\n  })\n}</code></pre>\n<p>Ensuite on ajoute un √©couteur d'√©v√©nement de clics sur le canvas principal et on capture les informations du pixel sur le buffer avec les coordonn√©es donn√© par l'√©venement.</p>\n<pre><code class=\"language-javascript\">this.canvas.addEventListener(&#039;click&#039;, event =&gt; {\n  let color = this.inputCanvasCtx.getImageData(event.layerX, event.layerY, 1, 1).data\n})</code></pre>\n<p>Il nous suffit alors de convertir la couleur RGB en HEX et comparer les couleurs!</p>\n<pre><code class=\"language-javascript\">this.canvas.addEventListener(&#039;click&#039;, event =&gt; {\n  let color = this.inputCanvasCtx.getImageData(event.layerX, event.layerY, 1, 1).data\n  let hexColor = (&quot;000000&quot; + this.rgbToHex(color[0], color[1], color[2])).slice(-6)\n\n  console.log(&#039;You just clicked on color #&#039; + hexColor)\n\n  let sprite = this.sprites.filter(sprite =&gt; sprite.id === hexColor)\n  // On a alors la sprite cliqu√©e\n})\n\n...\n\n// RGB Util\nrgbToHex(r, g, b) {\n  if (r &gt; 255 || g &gt; 255 || b &gt; 255)\n      throw &quot;Invalid color component&quot;\n  return ((r &lt;&lt; 16) | (g &lt;&lt; 8) | b).toString(16)\n}</code></pre>\n<p>Retour Console:</p>\n<p><img decoding=\"async\" src=\"https://raw.githubusercontent.com/Leoche/Pixelperfect-Click-Canvas/master/docs/assets/ill4.png\" alt=\"ill4\" /></p>\n<p>On a alors la sprite cliqu√©e de mani√®re totalement pixel perfect</p>\n<p>En esp√©rant que √ßa aide quelqu'un un jour üôÇ !</p>\n<p><a href=\"https://github.com/Leoche/Pixelperfect-Click-Canvas\">Liens vers le Repo</a></p>\n<p><a href=\"https://leoche.github.io/Pixelperfect-Click-Canvas\">Liens vers la D√©mo</a></p>\n",
            "excerpt": "<p>Il n&#8217;y a aucun moyen de dessiner un sprite et de capturer un clique de mani√®re pixel perfect sur un canvas HTML5. Mais il y&#8217;a une astuce&#8230;</p>\n"
          }
        ]
      },
      {
        "title": "Devlog #2: Isometric map",
        "slug": "devlog-2-isometric-map",
        "content": "<p>This week I set out to create a game base and my plan was to use Phaser! But in the end, I decided to start from scratch. I was able to create a Gameloop, a renderer, and sprites.</p>\n<pre><code class=\"language-javascript\">// Game.js\nconstructor(socket) {\n    this.renderer = new Renderer()\n    this.loop = this.loop.bind(this)Ôªø;\n    this.fps = 30\n    this.interval = 1000/this.fps\n    this.lastTime = (new Date()).getTime()\n    this.currentTime = 0\n    this.delta = 0\n  }\n  update () {\n\n  }\n  render () {\n      this.renderer.render(this.sprites)\n  }\n  loop () {\n    window.requestAnimationFrame(() =&gt; { this.loop() })\n    this.update()\n    this.currentTime = (new Date()).getTime()\n    this.delta = (this.currentTime-this.lastTime)\n\n    if(this.delta &gt; this.interval) {\n        this.render()\n        this.lastTime = this.currentTime - (this.delta % this.interval)\n    }\n  }</code></pre>\n<p>With a polyfill for the <code>RAF</code></p>\n<pre><code class=\"language-javascript\">export function setRequestAnimationFrame () {\n  var vendors = [&#039;webkit&#039;, &#039;moz&#039;];\n  for(var x = 0; x &lt; vendors.length &amp;&amp; !window.requestAnimationFrame; ++x) {\n      window.requestAnimationFrame = window[vendors[x]+&#039;RequestAnimationFrame&#039;];\n      window.cancelAnimationFrame =\n        window[vendors[x]+&#039;CancelAnimationFrame&#039;] || window[vendors[x]+&#039;CancelRequestAnimationFrame&#039;];\n  }\n}</code></pre>\n<p>I was able to then create a <code>Room</code> class that takes the maps from the Tiled software and renders them on the screen:</p>\n<p><img decoding=\"async\" src=\"//images.ctfassets.net/h9l0gdn8tp2b/6qeTTzNrXyQ202UscOwCGq/7d3e8492bc9e0987696c21a5d141b520/2018-09-17-125341_1455x803_scrot.png\" alt=\"2018-09-17-125341 1455x803 scrot\" /></p>\n<p><img decoding=\"async\" src=\"//images.ctfassets.net/h9l0gdn8tp2b/5kN4669oSAmiAcUcQssQs4/3edd0d6ccd33cf4495d888927b310cca/2018-09-17-103536_478x254_scrot.png\" alt=\"2018-09-17-103536 478x254 scrot\" /></p>\n<p>The map is draggable and a cursor exists to click or select a Tile using an ortho &lt;-&gt; iso projection:</p>\n<pre><code class=\"language-javascript\">map.x = (pointer.x / TILE_WIDTH_HALF +  pointer.y / TILE_HEIGHT_HALF) /2;\nmap.y = (pointer.y / TILE_HEIGHT_HALF - (pointer.x / TILE_WIDTH_HALF)) /2;</code></pre>\n<p>Here is the result :</p>\n<p><img decoding=\"async\" src=\"//images.ctfassets.net/h9l0gdn8tp2b/5DMbv1n8J2O8AOeoQa8QGw/15b1eda5771d04258958b255b19f0017/ezgif.com-optimize.gif\" alt=\"ezgif.com-optimize\" /></p>\n",
        "excerpt": "<p>This week I set out to create a game base and my plan was to use Phaser! But in the end, I decided to start from scratch. I was able to create a Gameloop, a renderer, and sprites. // Game.js constructor(socket) { this.renderer = new Renderer() this.loop = this.loop.bind(this)Ôªø; this.fps = 30 this.interval = 1000/this.fps [&hellip;]</p>\n",
        "featuredImage": {
          "node": {
            "sourceUrl": "https://wp.leodesigaux.com/wp-content/uploads/2024/09/carre.png"
          }
        },
        "categories": {
          "edges": [
            {
              "node": {
                "name": "Gamedev",
                "slug": "gamedev"
              }
            }
          ]
        },
        "author": {
          "node": {
            "name": "Leoche",
            "avatar": {
              "url": "https://secure.gravatar.com/avatar/725d10949bebbbcebf092ade3d520748?s=96&d=mm&r=g"
            }
          }
        },
        "date": "2023-11-30T21:13:32",
        "modified": "2024-09-30T21:16:31",
        "translations": [
          {
            "title": "Devlog #2: Isometric map",
            "slug": "devlog-2-isometric-map-2",
            "content": "<p>Cette semaine je me suis attel√© √† cr√©er une base du jeu et j'avais pour projet d'utiliser Phaser! Mais au final j'ai d√©cid√© de m'y mettre from scratch. J'ai pu cr√©e une Gameloop un renderer et des sprites.</p>\n<pre><code class=\"language-javascript\">// Game.js\nconstructor(socket) {\n    this.renderer = new Renderer()\n    this.loop = this.loop.bind(this)Ôªø;\n    this.fps = 30\n    this.interval = 1000/this.fps\n    this.lastTime = (new Date()).getTime()\n    this.currentTime = 0\n    this.delta = 0\n  }\n  update () {\n\n  }\n  render () {\n      this.renderer.render(this.sprites)\n  }\n  loop () {\n    window.requestAnimationFrame(() =&gt; { this.loop() })\n    this.update()\n    this.currentTime = (new Date()).getTime()\n    this.delta = (this.currentTime-this.lastTime)\n\n    if(this.delta &gt; this.interval) {\n        this.render()\n        this.lastTime = this.currentTime - (this.delta % this.interval)\n    }\n  }</code></pre>\n<p>Avec un polyfill pour le <code>RAF</code></p>\n<pre><code class=\"language-javascript\">export function setRequestAnimationFrame () {\n  var vendors = [&#039;webkit&#039;, &#039;moz&#039;];\n  for(var x = 0; x &lt; vendors.length &amp;&amp; !window.requestAnimationFrame; ++x) {\n      window.requestAnimationFrame = window[vendors[x]+&#039;RequestAnimationFrame&#039;];\n      window.cancelAnimationFrame =\n        window[vendors[x]+&#039;CancelAnimationFrame&#039;] || window[vendors[x]+&#039;CancelRequestAnimationFrame&#039;];\n  }\n}</code></pre>\n<p>J'ai pu cr√©e alors une classe <code>Room</code> qui prend alors les map du logiciel Tiled et cr√©e leur rendu √† l'√©cran:</p>\n<p><img decoding=\"async\" src=\"//images.ctfassets.net/h9l0gdn8tp2b/6qeTTzNrXyQ202UscOwCGq/7d3e8492bc9e0987696c21a5d141b520/2018-09-17-125341_1455x803_scrot.png\" alt=\"2018-09-17-125341 1455x803 scrot\" /></p>\n<p><img decoding=\"async\" src=\"//images.ctfassets.net/h9l0gdn8tp2b/5kN4669oSAmiAcUcQssQs4/3edd0d6ccd33cf4495d888927b310cca/2018-09-17-103536_478x254_scrot.png\" alt=\"2018-09-17-103536 478x254 scrot\" /></p>\n<p>La map est draggable et un curseur existe pour cliquer ou selectionner une Tile gr√¢ce √† une projection ortho &lt;-&gt; iso:</p>\n<pre><code class=\"language-javascript\">map.x = (pointer.x / TILE_WIDTH_HALF +  pointer.y / TILE_HEIGHT_HALF) /2;\nmap.y = (pointer.y / TILE_HEIGHT_HALF - (pointer.x / TILE_WIDTH_HALF)) /2;</code></pre>\n<p>Voici le r√©sultat pour le moment :</p>\n<p><img decoding=\"async\" src=\"//images.ctfassets.net/h9l0gdn8tp2b/5DMbv1n8J2O8AOeoQa8QGw/15b1eda5771d04258958b255b19f0017/ezgif.com-optimize.gif\" alt=\"ezgif.com-optimize\" /></p>\n",
            "excerpt": "<p>Cette semaine je me suis attel√© √† cr√©er une base du jeu et j&#8217;avais pour projet d&#8217;utiliser Phaser! Mais au final j&#8217;ai d√©cid√© de m&#8217;y mettre from scratch. J&#8217;ai pu cr√©e une Gameloop un renderer et des sprites. // Game.js constructor(socket) { this.renderer = new Renderer() this.loop = this.loop.bind(this)Ôªø; this.fps = 30 this.interval = 1000/this.fps [&hellip;]</p>\n"
          }
        ]
      },
      {
        "title": "Devlog #1: Socket.io Auth",
        "slug": "devlog-1-socket-io-auth",
        "content": "<p>First devlog of a project that has been close to my heart for a few years: PixelOnline (even though the name is still not fixed). It is an online game playable in browsers. It would be isometric and massively multiplayer.</p>\n<p>As for the technology, I am opting for a backend using socket.io/express + mongodb. Phaser and pixel art for the frontend. At the moment, I am only creating basic features (connection, window manager) to have a game base more oriented towards sandbox.</p>\n<p>At this stage of this first week of September, I was able to finish the Login and registration system by adding a token system to stay connected. I also managed to create a small notification system (basic at the moment).</p>\n<p>On the server side, I created a Database class that works both with mongoDB and without any DB at all, meaning just with volatile arrays (Basically you need to register each time the server restarts.)</p>\n<p><em>Login process diagram</em><br />\n<img decoding=\"async\" src=\"//images.ctfassets.net/h9l0gdn8tp2b/2jj7j2qWTq8Y642u6W8k2c/5fae206755fd0eccc2a3250e4a62cdba/Login__1_.png\" alt=\"Login (1)\" /></p>\n<p>As for the roadmap, I would like for next week, a panel to see all registered and online players, a functional chat, and a chat with the server to be able to communicate with it and evaluate what I send to it and have it return its result on its side. Once that's done, I think I can really start the game.</p>\n<p>I leave you with some small UI screens (temporary).</p>\n<p><em>Login Pane</em><br />\n<img decoding=\"async\" src=\"//images.ctfassets.net/h9l0gdn8tp2b/6IEkkljtx6qEAeQQ2UA0Ci/7281cf536d7bfe1978fab63b1069361d/2018-09-10-134313_481x420_scrot.png\" alt=\"2018-09-10-134313 481x420 scrot\" /></p>\n<p><em>Register Pane</em><br />\n<img decoding=\"async\" src=\"//images.ctfassets.net/h9l0gdn8tp2b/5zqw0uZKvKQQA4q4qeI266/0ffd60f54a7caaa4ec0442e11e551357/2018-09-10-134959_350x398_scrot.png\" alt=\"2018-09-10-134959 350x398 scrot\" /></p>\n<p><em>Buttons</em><br />\n<img decoding=\"async\" src=\"//images.ctfassets.net/h9l0gdn8tp2b/5iCOxTbSwwyQceI0Eskcc/921b79f35caf609171cdea05ece212c2/2018-09-10-134949_111x101_scrot.png\" alt=\"2018-09-10-134949 111x101 scrot\" /></p>\n<p>Github: <a href=\"https://github.com/Leoche/PixelOnline\">Repo of the projet</a></p>\n",
        "excerpt": "<p>First devlog of a project that has been close to my heart for a few years: PixelOnline (even though the name is still not fixed). It is an online game playable in browsers. It would be isometric and massively multiplayer. As for the technology, I am opting for a backend using socket.io/express + mongodb. Phaser [&hellip;]</p>\n",
        "featuredImage": {
          "node": {
            "sourceUrl": "https://wp.leodesigaux.com/wp-content/uploads/2024/09/2018-09-10-134317_811x704_scrot.png"
          }
        },
        "categories": {
          "edges": [
            {
              "node": {
                "name": "Gamedev",
                "slug": "gamedev"
              }
            }
          ]
        },
        "author": {
          "node": {
            "name": "Leoche",
            "avatar": {
              "url": "https://secure.gravatar.com/avatar/725d10949bebbbcebf092ade3d520748?s=96&d=mm&r=g"
            }
          }
        },
        "date": "2023-09-30T21:09:35",
        "modified": "2024-09-30T21:12:27",
        "translations": [
          {
            "title": "Devlog #1: Socket.io Auth",
            "slug": "devlog-1-socket-io-auth-2",
            "content": "<p>Voici le premier devlog d'un projet qui me tiens √† coeur depuis quelques ann√©es: PixelOnline (m√™me si le nom n'est toujours pas encore fixe). C'est un jeu en ligne jouable sur les navigateur. Il serait isom√©trique et massivement multijoueur.</p>\n<p>Pour ce qui est de la techno j'opte pour un back socket.io/express + mongodb. Phaser et du pixelart pour le front. Pour le moment, je cr√©e uniquement les fonctionnalit√©s de base (connexion, windowmanager) pour avoir une base jeu plut√¥t orient√© sandbox.</p>\n<p>A ce stade de cette premi√®re semaine de Septembre. J'ai pu finir le syst√®me de Login et d'inscription en y ajoutant un syst√®me de token pour rester connect√©. J'ai pu aussi r√©aliser un petit syst√®me de notification (basique pour le moment).</p>\n<p>Cot√© serveur j'ai cr√©√© une classe Database qui marche autant via mongoDB autant sans DB du tout, c'est √† dire juste avec des arrays volatiles (En gros il faut se register √† chaque red√©marrage serveur.)</p>\n<p><em>Diagrame du process de Login</em><br />\n<img decoding=\"async\" src=\"//images.ctfassets.net/h9l0gdn8tp2b/2jj7j2qWTq8Y642u6W8k2c/5fae206755fd0eccc2a3250e4a62cdba/Login__1_.png\" alt=\"Login (1)\" /></p>\n<p>Pour ce qui est de la roadmap, J'aimerai pour la semaine prochaine, un panneau pour voir tous les joueurs inscrit et en ligne, un tchat fonctionnel et un tchat avec le serveur pour pouvoir communiquer avec lui et pouvoir √©valuer ce que je lui envois et qu'il me retourne son r√©sultat de son cot√©. Une fois √ßa fait je pense pouvoir commencer le jeu r√©ellement.</p>\n<p>Je vous laisse avec des petits screens de l'ui (temporaire)</p>\n<p><em>Login Pane</em><br />\n<img decoding=\"async\" src=\"//images.ctfassets.net/h9l0gdn8tp2b/6IEkkljtx6qEAeQQ2UA0Ci/7281cf536d7bfe1978fab63b1069361d/2018-09-10-134313_481x420_scrot.png\" alt=\"2018-09-10-134313 481x420 scrot\" /></p>\n<p><em>Register Pane</em><br />\n<img decoding=\"async\" src=\"//images.ctfassets.net/h9l0gdn8tp2b/5zqw0uZKvKQQA4q4qeI266/0ffd60f54a7caaa4ec0442e11e551357/2018-09-10-134959_350x398_scrot.png\" alt=\"2018-09-10-134959 350x398 scrot\" /></p>\n<p><em>Buttons</em><br />\n<img decoding=\"async\" src=\"//images.ctfassets.net/h9l0gdn8tp2b/5iCOxTbSwwyQceI0Eskcc/921b79f35caf609171cdea05ece212c2/2018-09-10-134949_111x101_scrot.png\" alt=\"2018-09-10-134949 111x101 scrot\" /></p>\n<p>Github: <a href=\"https://github.com/Leoche/PixelOnline\">Repo du projet</a></p>\n",
            "excerpt": "<p>Voici le premier devlog d&#8217;un projet qui me tiens √† coeur depuis quelques ann√©es: PixelOnline (m√™me si le nom n&#8217;est toujours pas encore fixe). C&#8217;est un jeu en ligne jouable sur les navigateur. Il serait isom√©trique et massivement multijoueur. Pour ce qui est de la techno j&#8217;opte pour un back socket.io/express + mongodb. Phaser et [&hellip;]</p>\n"
          }
        ]
      }
    ]
  }
}